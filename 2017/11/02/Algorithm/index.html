<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>剑指offer算法编程题（Python、C++、Java） | 指尖の岁月 | 世间点滴，莫忘于心</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Algorithm">
    <meta name="description" content="主要考点涵盖了基本数据结构，基础逻辑和算法应用以及智力题。 数据结构主要考察数据结构在现实算法中的实际应用和变形转换。 链表（linked list）从尾到头打印链表题目：输入一个链表，从尾到头打印链表每个节点的值。Input： {67,0,24,58} Output： [58,24,0,67] Requirement： Time limit = 1s, Space limit = 32768K">
<meta name="keywords" content="Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer算法编程题（Python、C++、Java）">
<meta property="og:url" content="http://yoursite.com/2017/11/02/Algorithm/index.html">
<meta property="og:site_name" content="指尖の岁月">
<meta property="og:description" content="主要考点涵盖了基本数据结构，基础逻辑和算法应用以及智力题。 数据结构主要考察数据结构在现实算法中的实际应用和变形转换。 链表（linked list）从尾到头打印链表题目：输入一个链表，从尾到头打印链表每个节点的值。Input： {67,0,24,58} Output： [58,24,0,67] Requirement： Time limit = 1s, Space limit = 32768K">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-11-02T05:58:59.042Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer算法编程题（Python、C++、Java）">
<meta name="twitter:description" content="主要考点涵盖了基本数据结构，基础逻辑和算法应用以及智力题。 数据结构主要考察数据结构在现实算法中的实际应用和变形转换。 链表（linked list）从尾到头打印链表题目：输入一个链表，从尾到头打印链表每个节点的值。Input： {67,0,24,58} Output： [58,24,0,67] Requirement： Time limit = 1s, Space limit = 32768K">
    
        <link rel="alternate" type="application/atom+xml" title="指尖の岁月" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/new3.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/one2.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Eternal</h5>
          <a href="mailto:617844662@qq.com" title="617844662@qq.com" class="mail">617844662@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/EternalFeather" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://EternalFeather.github.io/AboutMe/" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                About Me
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">剑指offer算法编程题（Python、C++、Java）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">剑指offer算法编程题（Python、C++、Java）</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-11-02T05:44:14.000Z" itemprop="datePublished" class="page-time">
  2017-11-02
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数据结构"><span class="post-toc-number">1.</span> <span class="post-toc-text">数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#链表（linked-list）"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">链表（linked list）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从尾到头打印链表"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">从尾到头打印链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链表中倒数第k个结点"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">链表中倒数第k个结点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#合并两个排序的链表"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">合并两个排序的链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两个链表的第一个交点"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">两个链表的第一个交点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链表中环的入口"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">链表中环的入口</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#树（tree）"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">树（tree）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的镜像"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">二叉树的镜像</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重构二叉树"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">重构二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#树的子结构"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">树的子结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的广度优先检索"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">二叉树的广度优先检索</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的后序遍历序列"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">二叉树的后序遍历序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的下一个节点"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">二叉树的下一个节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的对称"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">二叉树的对称</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符串（string）"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">字符串（string）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#替换空格"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">替换空格</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串的全排列"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">字符串的全排列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#第一次只出现一次的字符"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">第一次只出现一次的字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#左旋转字符"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">左旋转字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#翻转单词顺序列"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">翻转单词顺序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#把字符串转换成整数"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">把字符串转换成整数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#表示数值的字符串"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">表示数值的字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符流中第一次只出现一次的字符"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">字符流中第一次只出现一次的字符</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组（array）"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">数组（array）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二维数组中的查找"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">二维数组中的查找</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调整数组顺序让基数位于偶数前面"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">调整数组顺序让基数位于偶数前面</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组中最小的k个数"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">数组中最小的k个数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#连续子数组的最大和"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">连续子数组的最大和</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#把数组排成最小的数"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">把数组排成最小的数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#丑数"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">丑数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组中只出现一次的数字"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">数组中只出现一次的数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组中重复的数字"><span class="post-toc-number">1.4.8.</span> <span class="post-toc-text">数组中重复的数字</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#栈和堆叠（stack-amp-heap）"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">栈和堆叠（stack & heap）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用两个栈实现队列"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">用两个栈实现队列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#包含min函数的栈"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">包含min函数的栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#栈的压入与弹出序列"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">栈的压入与弹出序列</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#智力题和知识迁移"><span class="post-toc-number">2.</span> <span class="post-toc-text">智力题和知识迁移</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#矩阵覆盖"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">矩阵覆盖</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#顺时针打印矩阵"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">顺时针打印矩阵</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#复杂链表的复制"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">复杂链表的复制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉检索树转换成双向链表"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">二叉检索树转换成双向链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#整数中1出现的次数"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">整数中1出现的次数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#扑克牌顺子"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">扑克牌顺子</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#孩子们的游戏（环中剩下的数）"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">孩子们的游戏（环中剩下的数）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-3-4-…-n"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">1+2+3+4+…+n</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#构建乘积数组"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">构建乘积数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正则表达式"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">正则表达式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#之字形打印二叉树"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">之字形打印二叉树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列化和反序列化二叉树"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">序列化和反序列化二叉树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#滚动窗口的最大值"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">滚动窗口的最大值</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#机器人的运动范围"><span class="post-toc-number">2.14.</span> <span class="post-toc-text">机器人的运动范围</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#基本算法和逻辑"><span class="post-toc-number">3.</span> <span class="post-toc-text">基本算法和逻辑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#递归和循环（recursive-amp-recurrent）"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">递归和循环（recursive & recurrent）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#斐波那契数列"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">斐波那契数列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#普通跳台阶问题"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">普通跳台阶问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#跳台阶进阶问题"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">跳台阶进阶问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数值的整数次方"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">数值的整数次方</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的深度"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">二叉树的深度</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#删除链表中重复的结点"><span class="post-toc-number">3.1.6.</span> <span class="post-toc-text">删除链表中重复的结点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#矩阵中的路径"><span class="post-toc-number">3.1.7.</span> <span class="post-toc-text">矩阵中的路径</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查找和排序（search-amp-sort）"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">查找和排序（search & sort）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#旋转数组的最小数字"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">旋转数组的最小数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组中出现次数超过一半的数"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">数组中出现次数超过一半的数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树中和为某一值的路径"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">二叉树中和为某一值的路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数字在排序数组中出现的次数"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">数字在排序数组中出现的次数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#和为定值的连续正数序列"><span class="post-toc-number">3.2.5.</span> <span class="post-toc-text">和为定值的连续正数序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#和为定制的两个数"><span class="post-toc-number">3.2.6.</span> <span class="post-toc-text">和为定制的两个数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉树的分层列印"><span class="post-toc-number">3.2.7.</span> <span class="post-toc-text">二叉树的分层列印</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二叉检索树的第k大节点"><span class="post-toc-number">3.2.8.</span> <span class="post-toc-text">二叉检索树的第k大节点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#位运算"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">位运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二进制中1的个数"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">二进制中1的个数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不用加减乘除做加法"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">不用加减乘除做加法</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-Algorithm"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">剑指offer算法编程题（Python、C++、Java）</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-11-02 13:44:14" datetime="2017-11-02T05:44:14.000Z"  itemprop="datePublished">2017-11-02</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>主要考点涵盖了基本数据结构，基础逻辑和算法应用以及智力题。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>主要考察数据结构在现实算法中的实际应用和变形转换。</p>
<h2 id="链表（linked-list）"><a href="#链表（linked-list）" class="headerlink" title="链表（linked list）"></a>链表（linked list）</h2><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>题目：输入一个链表，从尾到头打印链表每个节点的值。<br><strong>Input：</strong></p>
<p>{67,0,24,58}</p>
<p><strong>Output：</strong></p>
<p>[58,24,0,67]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题属于基本题，最直接的思路就是使用一个栈（stack）结构来依次存取数组中所有的元素，然后将stack的值按顺序pop即为答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line"></div><div class="line">class Solution:</div><div class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</div><div class="line">    def printListFromTailToHead(self, listNode):</div><div class="line">        # write code here</div><div class="line">        if listNode is None:</div><div class="line">            return []</div><div class="line">        stack = []</div><div class="line">        while listNode is not None:</div><div class="line">            stack.append(listNode.val)</div><div class="line">            listNode = listNode.next</div><div class="line">        return stack[::-1]</div></pre></td></tr></table></figure>
<h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><p>题目：输入一个链表，输出该链表中倒数第k个结点。<br><strong>Input：</strong></p>
<p>1, {1,2,3,4,5}</p>
<p><strong>Output：</strong></p>
<p>{5}</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题可以使用双指针解决，定义一前一后两个指针。让前指针先走k次，然后指针同时前进，当前指针到达链表尾部时，后指针所指的就是所要求的倒数第k个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution:</div><div class="line">    def FindKthToTail(self, head, k):</div><div class="line">        # write code here</div><div class="line">        if head is None:</div><div class="line">            return None</div><div class="line">        count = k</div><div class="line">        first = head</div><div class="line">        second = None</div><div class="line">        while count:</div><div class="line">            if first is not None:</div><div class="line">            	first = first.next</div><div class="line">            	count -= 1</div><div class="line">            else:</div><div class="line">                return None</div><div class="line">        second = head</div><div class="line">        while first is not None:</div><div class="line">            first = first.next</div><div class="line">            second = second.next</div><div class="line">        return second</div></pre></td></tr></table></figure>
<h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><strong>Input：</strong></p>
<p>{1,3,5}, {2,4,6}</p>
<p><strong>Output：</strong></p>
<p>{1,2,3,4,5,6}</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本体主要的条件是已排序，所以我们只要依次比较两个链表的最左端元素大小，依次插入新的链表即可。具体流程可使用递归的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    # 返回合并后列表</div><div class="line">    def Merge(self, pHead1, pHead2):</div><div class="line">        # write code here</div><div class="line">        if pHead1 == None:</div><div class="line">            return pHead2</div><div class="line">        elif pHead2 == None:</div><div class="line">            return pHead1</div><div class="line">        newHead = ListNode(0)</div><div class="line">        if pHead1.val &lt; pHead2.val:</div><div class="line">            newHead.val = pHead1.val</div><div class="line">            newHead.next = self.Merge(pHead1.next, pHead2)</div><div class="line">        else:</div><div class="line">            newHead.val = pHead2.val</div><div class="line">            newHead.next = self.Merge(pHead1, pHead2.next)</div><div class="line">        return newHead</div></pre></td></tr></table></figure>
<h3 id="两个链表的第一个交点"><a href="#两个链表的第一个交点" class="headerlink" title="两个链表的第一个交点"></a>两个链表的第一个交点</h3><p>题目：输入两个链表，找出它们的第一个公共结点。<br><strong>Input：</strong></p>
<p>{1,2,3,6,7}, {4,5,6,7}</p>
<p><strong>Output：</strong></p>
<p>6</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 两个链表有公共节点，其必定共用结尾，因此可以计算两个链表的长度差，然后让长的先走相差的步数。最后两个链表同时移动，判断相同的点为公共点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def findlength(self, pHead):</div><div class="line">        count = 0</div><div class="line">        while pHead:</div><div class="line">            count += 1</div><div class="line">            pHead = pHead.next</div><div class="line">        return count</div><div class="line">    def FindFirstCommonNode(self, pHead1, pHead2):</div><div class="line">        # write code here</div><div class="line">        if not pHead1 or not pHead2:</div><div class="line">            return None</div><div class="line">        len_one = self.findlength(pHead1)</div><div class="line">        len_two = self.findlength(pHead2)</div><div class="line">        dis = abs(len_one - len_two)</div><div class="line">        if len_one &gt; len_two:</div><div class="line">            while dis:</div><div class="line">                pHead1 = pHead1.next</div><div class="line">                dis -= 1</div><div class="line">        elif len_one &lt; len_two:</div><div class="line">            while dis:</div><div class="line">                pHead2 = pHead2.next</div><div class="line">                dis -= 1</div><div class="line">        while pHead1:</div><div class="line">            if pHead1.val == pHead2.val:</div><div class="line">                return pHead1</div><div class="line">            else:</div><div class="line">                pHead1 = pHead1.next</div><div class="line">                pHead2 = pHead2.next</div><div class="line">        return None</div></pre></td></tr></table></figure>
<h3 id="链表中环的入口"><a href="#链表中环的入口" class="headerlink" title="链表中环的入口"></a>链表中环的入口</h3><p>题目：一个链表中包含环，请找出该链表的环的入口结点。<br><strong>Input：</strong></p>
<p>{1,2}, {3,4,5}</p>
<p><strong>Output：</strong></p>
<p>3</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题可以使用快慢指针，1个速度2倍于满指针的快指针。两指针一起移动，相遇的时候快指针在环中的距离为慢指针的2倍。此时慢指针距离入口的距离恰好等于起点距离入口的一半。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def EntryNodeOfLoop(self, pHead):</div><div class="line">        # write code here</div><div class="line">        if not pHead or not pHead.next:</div><div class="line">            return None</div><div class="line">        slow = pHead.next</div><div class="line">        fast = pHead.next.next</div><div class="line">        while slow != fast:</div><div class="line">            slow = slow.next</div><div class="line">            fast = fast.next.next</div><div class="line">        fast = pHead</div><div class="line">        while fast != slow:</div><div class="line">            fast = fast.next</div><div class="line">            slow = slow.next</div><div class="line">        return fast</div></pre></td></tr></table></figure>
<h2 id="树（tree）"><a href="#树（tree）" class="headerlink" title="树（tree）"></a>树（tree）</h2><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。<br><strong>Input：</strong></p>
<p>{8,6,10,5,7,9,11}</p>
<p><strong>Output：</strong></p>
<p>{8,10,6,11,9,7,5}</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题的主要观念还是在<strong>树结构</strong>的问题上，由于题目给定的是二叉树，因此只会有左子节点和右子节点。值得注意的是在交换父节点的同时，父节点对应的子节点也跟着交换，这点符合镜像的要求，因此可以考虑使用<strong>递归</strong>的方式来实现这个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line"></div><div class="line">class Solution:</div><div class="line">    # 返回镜像树的根节点</div><div class="line">    def transform(self, node):</div><div class="line">        temp = node.left</div><div class="line">        node.left = node.right</div><div class="line">        node.right = temp</div><div class="line">        </div><div class="line">    def Mirror(self, root):</div><div class="line">        # write code here</div><div class="line">        if root is not None:</div><div class="line">            self.transform(root)</div><div class="line">            self.Mirror(root.left)</div><div class="line">            self.Mirror(root.right)</div></pre></td></tr></table></figure>
<h3 id="重构二叉树"><a href="#重构二叉树" class="headerlink" title="重构二叉树"></a>重构二叉树</h3><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><strong>Input：</strong></p>
<p>{1,2,3,4,5,6,7}, {3,2,4,1,6,5,7}</p>
<p><strong>Output：</strong></p>
<p>{1,2,5,3,4,6,7}， root = 1</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本体需要了解的关键点包括：树的遍历性质，递归的思维步骤等。先序遍历总是优先打印当前最大子树的root节点，而root节点的所有左子树的元素在中序遍历中必定出现在root前，相反右子树的所有元素都在后。根据这些性质就能够根据递归的思路对数的结构进行拆解，最后回归整棵树的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</div><div class="line">        int cand = pre[0];</div><div class="line">        if (vin.size() == 0)&#123;</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        TreeNode* head = new TreeNode(cand);</div><div class="line">        vector&lt;int&gt; left_pre, right_pre, left_in, right_in;</div><div class="line">        int count = 0;</div><div class="line">        for (int i = 0; i &lt; vin.size(); i++)&#123;</div><div class="line">            if (vin[i] == cand)&#123;</div><div class="line">                count = i;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; count; i++)&#123;</div><div class="line">            left_pre.push_back(pre[i+1]);</div><div class="line">            left_in.push_back(vin[i]);</div><div class="line">        &#125;</div><div class="line">        for (int i = count+1; i &lt; vin.size(); i++)&#123;</div><div class="line">            right_pre.push_back(pre[i]);</div><div class="line">            right_in.push_back(vin[i]);</div><div class="line">        &#125;</div><div class="line">        head -&gt; left = reConstructBinaryTree(left_pre, left_in);</div><div class="line">        head -&gt; right = reConstructBinaryTree(right_pre, right_in);</div><div class="line">        return head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><strong>Input：</strong></p>
<p>{8,8,7,9,3,#,#,#,#,4,7}, {8,9,2}</p>
<p><strong>Output：</strong></p>
<p>False</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题用到的数据结构是二叉树，看到题目不难想到利用DFS的思路顺势搜索下去，如果能够找到答案就返回True，不行就返回False。DFS的行为主要依赖于递归的算法，对每一个节点进行深度检索，判断是否能够找到另一棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def search(self, root1, root2):</div><div class="line">        if root2 is None:</div><div class="line">            return True</div><div class="line">        if root1 is None or root1.val != root2.val:</div><div class="line">            return False</div><div class="line">        return self.search(root1.left, root2.left) and self.search(root1.right, root2.right)</div><div class="line">    def HasSubtree(self, pRoot1, pRoot2):</div><div class="line">        # write code here</div><div class="line">        if pRoot1 is None or pRoot2 is None:</div><div class="line">            return False</div><div class="line">        return self.search(pRoot1, pRoot2) or self.HasSubtree(pRoot1.left, pRoot2)</div></pre></td></tr></table></figure>
<h3 id="二叉树的广度优先检索"><a href="#二叉树的广度优先检索" class="headerlink" title="二叉树的广度优先检索"></a>二叉树的广度优先检索</h3><p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><strong>Input：</strong></p>
<p>{10,6,14,4,8,12,16}</p>
<p><strong>Output：</strong></p>
<p>[10,6,14,4,8,12,16]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题不需要考虑按层换行打印，因此难度稍微低了些。code中的last和nlast用来判断层的结束和遍历的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    # 返回从上到下每个节点值列表，例：[1,2,3]</div><div class="line">    def PrintFromTopToBottom(self, root):</div><div class="line">        # write code here</div><div class="line">        if root is None:</div><div class="line">            return []</div><div class="line">        queue = []</div><div class="line">        ans = []</div><div class="line">        last = root</div><div class="line">        nlast = root</div><div class="line">        queue.append(root)</div><div class="line">        while queue:</div><div class="line">            temp = queue.pop(0)</div><div class="line">            ans.append(temp.val)</div><div class="line">            if temp.left is not None:</div><div class="line">                queue.append(temp.left)</div><div class="line">                nlast = temp.left</div><div class="line">            if temp.right is not None:</div><div class="line">                queue.append(temp.right)</div><div class="line">                nlast = temp.right</div><div class="line">            if temp == last:</div><div class="line">                last = nlast</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="二叉树的后序遍历序列"><a href="#二叉树的后序遍历序列" class="headerlink" title="二叉树的后序遍历序列"></a>二叉树的后序遍历序列</h3><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><strong>Input：</strong></p>
<p>[4,6,7,5]</p>
<p><strong>Output：</strong></p>
<p>True</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 值得注意的关键条件是对于一个后续遍历的二叉树序列而言，最后一个元素永远是root结点。因此可以使用递归的方式判断root结点的左右子树（小于的节点在左边，大于的节点在右边）。两者的值连续分布，如果存在交叉或者奇异值，则判断条件不成立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def VerifySquenceOfBST(self, sequence):</div><div class="line">        # write code here</div><div class="line">        if not sequence:</div><div class="line">            return False</div><div class="line">        if len(sequence) == 1:</div><div class="line">            return True</div><div class="line">        temp = sequence.pop()</div><div class="line">        left = []</div><div class="line">        right = []</div><div class="line">        i = 0</div><div class="line">        while i &lt; len(sequence) and sequence[i] &lt; temp:</div><div class="line">            left.append(sequence[i])</div><div class="line">            i += 1</div><div class="line">        while i &lt; len(sequence):</div><div class="line">            if sequence[i] &lt; temp:</div><div class="line">                return False</div><div class="line">            right.append(sequence[i])</div><div class="line">            i += 1</div><div class="line">        left_flag = True</div><div class="line">        right_flag = True</div><div class="line">        if len(left):</div><div class="line">            left_flag = self.VerifySquenceOfBST(left)</div><div class="line">        if len(right):</div><div class="line">            right_flag = self.VerifySquenceOfBST(right)</div><div class="line">        return left_flag and right_flag</div><div class="line">``` </div><div class="line"></div><div class="line">### 平衡二叉树</div><div class="line">题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。</div><div class="line">**Input：**</div><div class="line"></div><div class="line">&#123;1,2,3,4,5,#,6,#,#,7&#125;</div><div class="line"></div><div class="line">**Output：**</div><div class="line"></div><div class="line">True</div><div class="line"></div><div class="line">**Requirement：**</div><div class="line"></div><div class="line">Time limit = 1s, Space limit = 32768K</div><div class="line"></div><div class="line">**思路：** 平衡二叉树的性质是最大的深度差不超过1，因此计算深度之后就能够容易得到结果。</div><div class="line"></div><div class="line">```python=</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def check(self, root):</div><div class="line">        if not root:</div><div class="line">            return 0</div><div class="line">        left = self.check(root.left)</div><div class="line">        right = self.check(root.right)</div><div class="line">        return max(left + 1, right + 1)</div><div class="line">    def IsBalanced_Solution(self, pRoot):</div><div class="line">        # write code here</div><div class="line">        if not pRoot:</div><div class="line">            return True</div><div class="line">        if abs(self.check(pRoot.left) - self.check(pRoot.right)) &gt; 1:</div><div class="line">            return False</div><div class="line">        else:</div><div class="line">            return True</div></pre></td></tr></table></figure>
<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p>题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><strong>Input：</strong></p>
<p>{8,6,10,5,7,9,11}, 5</p>
<p><strong>Output：</strong></p>
<p>6</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题属于一个递归的思路，需要熟悉二叉树的中序遍历特点。首先如果一个node有右节点，那么我们就会去寻找这个右节点的左子树的最左节点。如果右节点不存在的时候我们就会去找父节点，如果父节点的左节点就是当前节点，那么父节点就是下一个输出的对象。这个需要考虑几个特殊情况，例如root节点，如果没有右节点，那么没有下一个节点；右子树的最右节点，没有next节点等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeLinkNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def findleft(self, pNode):</div><div class="line">        while pNode.left:</div><div class="line">            pNode = pNode.left</div><div class="line">        return pNode</div><div class="line">    def GetNext(self, pNode):</div><div class="line">        # write code here</div><div class="line">        if not pNode:</div><div class="line">            return None</div><div class="line">        if pNode.right:</div><div class="line">            return self.findleft(pNode.right)</div><div class="line">        else:</div><div class="line">            temp = pNode</div><div class="line">            while temp.next:</div><div class="line">                temp = pNode.next</div><div class="line">                if temp.left == pNode:</div><div class="line">                    return temp</div><div class="line">                pNode = temp</div><div class="line">            return None</div></pre></td></tr></table></figure>
<h3 id="二叉树的对称"><a href="#二叉树的对称" class="headerlink" title="二叉树的对称"></a>二叉树的对称</h3><p>题目：请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><strong>Input：</strong></p>
<p>{8,6,6,5,7,7,5}</p>
<p><strong>Output：</strong></p>
<p>True</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 该题的思路比较明确，就是判断二叉树的镜像是否相同，利用递归可以很好地解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def is_same(self, left, right):</div><div class="line">        if not left and not right:</div><div class="line">            return True</div><div class="line">        if left and right and left.val == right.val:</div><div class="line">            return self.is_same(left.left, right.right) and self.is_same(left.right, right.left)</div><div class="line">        return False</div><div class="line">    def isSymmetrical(self, pRoot):</div><div class="line">        # write code here</div><div class="line">        if not pRoot:</div><div class="line">            return True</div><div class="line">        if (pRoot.left and not pRoot.right) or (pRoot.right and not pRoot.left):</div><div class="line">            return False</div><div class="line">        return self.is_same(pRoot.left, pRoot.right)</div></pre></td></tr></table></figure>
<h2 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy。则经过替换之后的字符串为We%20Are%20Happy。<br><strong>Input：</strong></p>
<p>“hello world”</p>
<p><strong>Output：</strong></p>
<p>“hello%20world”</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本体使用python的replace function可以快速得到结果。如果使用C++或是Java需要考虑替换的长度变化问题。另外替换过程中如果从第一个元素开始替换，需要进行大量的元素位移，因此考虑时间复杂度应该考虑从最后一位进行替换。而在原有的数组中进行替换，就需要知道数组的元素新增多少个空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void replaceSpace(char *str,int length) &#123;</div><div class="line">        if (str == NULL || length &lt;0)</div><div class="line">            return;</div><div class="line">        int countspace = 0;</div><div class="line">        int oldlen = 0;</div><div class="line">        int i = 0;</div><div class="line">        while (str[i] != &apos;\0&apos;)&#123;</div><div class="line">            oldlen++;</div><div class="line">            if (str[i] == &apos; &apos;)</div><div class="line">                countspace++;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        int newlen = oldlen + 2*countspace;</div><div class="line">        if (newlen &gt; length)</div><div class="line">            return;</div><div class="line">        while (oldlen &gt;= 0 &amp;&amp; newlen &gt; oldlen)&#123;</div><div class="line">            if (str[oldlen] == &apos; &apos;)&#123;</div><div class="line">                str[newlen--] = &apos;0&apos;;</div><div class="line">                str[newlen--] = &apos;2&apos;;</div><div class="line">                str[newlen--] = &apos;%&apos;;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                str[newlen--] = str[oldlen];</div><div class="line">            oldlen--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h3><p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。<br><strong>Input：</strong></p>
<p>abc</p>
<p><strong>Output：</strong></p>
<p>abc,acb,bac,bca,cab,cba</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 全排列的问题可以看成是一个递归的过程，在固定第一个元素的基础上计算之后元素的排列数，以此类推。也可以理解成动态规划的问题，根据每一个元素在每一个位置出现的可能性，交换不同元素使之成为固定元素，然后计算其他元素的排列数，以此作为转换函数传递递归下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def swap(self, ss, i, j):</div><div class="line">        temp = ss[i]</div><div class="line">        ss[i] = ss[j]</div><div class="line">        ss[j] = temp</div><div class="line">        </div><div class="line">    def not_equal(self, ss, i, j):</div><div class="line">        for k in range(i, j):</div><div class="line">            if ss[k] == ss[j]:</div><div class="line">                return False</div><div class="line">        return True</div><div class="line">        </div><div class="line">    def permu(self, ss, temp, first, last):</div><div class="line">        if not ss or last &lt; 1:</div><div class="line">            return</div><div class="line">        if first == last:</div><div class="line">            temp.append(&quot;&quot;.join(ss))</div><div class="line">        else:</div><div class="line">            for i in range(first, last):</div><div class="line">                if self.not_equal(ss, first, i):</div><div class="line">                    self.swap(ss, first, i)</div><div class="line">                    self.permu(ss, temp, first + 1, last)</div><div class="line">                    self.swap(ss, first, i)</div><div class="line">            </div><div class="line">    def Permutation(self, ss):</div><div class="line">        # write code here</div><div class="line">        if not ss:</div><div class="line">            return []</div><div class="line">        ans = []</div><div class="line">        st = [i for i in ss]</div><div class="line">        self.permu(st, ans, 0, len(st))</div><div class="line">        return [&quot;&quot;.join(i) for i in ans]</div></pre></td></tr></table></figure>
<h3 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h3><p>题目：在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。<br><strong>Input：</strong></p>
<p>google</p>
<p><strong>Output：</strong></p>
<p>4</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题考察hash的用法以及字符类型字典的建构。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int FirstNotRepeatingChar(<span class="keyword">string</span> str) &#123;</div><div class="line">        <span class="keyword">if</span> (str.empty())&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        map&lt;char, int&gt; hash;</div><div class="line">        for (int i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</div><div class="line">            hash[str[i]]++;</div><div class="line">        &#125;</div><div class="line">        for (int i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span> (hash[str[i]] == <span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="左旋转字符"><a href="#左旋转字符" class="headerlink" title="左旋转字符"></a>左旋转字符</h3><p>题目：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。<br><strong>Input：</strong></p>
<p>abcdefg, 2</p>
<p><strong>Output：</strong></p>
<p>“cdefgab”</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 旋转字符属于基本的算法之一，其思路也有许多，包括最基本的取值平移（K位数直接平移）；以及3次反向（先对前k个取反，然后对后n-k个取反，最后对整个字符串取反）等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def LeftRotateString(self, s, n):</div><div class="line">        # write code here</div><div class="line">        if len(s) == 0:</div><div class="line">            return &quot;&quot;</div><div class="line">        if len(s) &lt;= n:</div><div class="line">            return s</div><div class="line">        left = s[:n]</div><div class="line">        right = s[n:]</div><div class="line">        ans = left[::-1] + right[::-1]</div><div class="line">        return ans[::-1]</div></pre></td></tr></table></figure>
<h3 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h3><p>题目：牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。后来才意识到，这家伙原来把句子单词的顺序翻转了。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<br><strong>Input：</strong></p>
<p>I am a student.</p>
<p><strong>Output：</strong></p>
<p>student. a am I</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题属于旋转字符串的运用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def ReverseSentence(self, s):</div><div class="line">        # write code here</div><div class="line">        temp = s.split(&quot; &quot;)</div><div class="line">        if len(temp) == 0:</div><div class="line">            return []</div><div class="line">        return &quot; &quot;.join(temp[::-1])</div></pre></td></tr></table></figure>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><p>题目：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br><strong>Input：</strong></p>
<p>+2147483647<br>    1a33</p>
<p><strong>Output：</strong></p>
<p>2147483647<br>    0</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 实作stoi函数，需要考虑的有4点：是否有无关字符，正负符号问题，空指针以及是否越界（超过integer临界值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int StrToInt(string str) &#123;</div><div class="line">        const char* temp = str.c_str();</div><div class="line">        const static int MAX_INT = (int)((unsigned)~0 &gt;&gt; 1);</div><div class="line">        const static int MIN_INT = -(int)((unsigned)~0 &gt;&gt; 1) - 1;</div><div class="line">        unsigned int ans = 0;</div><div class="line">        </div><div class="line">        if (*temp == &apos;\0&apos;)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while (isspace(*temp))&#123;</div><div class="line">            temp++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        int sign = 1;</div><div class="line">        if (*temp == &apos;+&apos; || *temp == &apos;-&apos;)&#123;</div><div class="line">            if (*temp == &apos;-&apos;)&#123;</div><div class="line">                sign = -1;</div><div class="line">            &#125;</div><div class="line">            temp++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while (*temp != &apos;\0&apos;)&#123;</div><div class="line">            if (isdigit(*temp))&#123;</div><div class="line">                int c = *temp - &apos;0&apos;;</div><div class="line">                if (sign &gt; 0 &amp;&amp; (ans &gt; MAX_INT / 10 || (ans == MAX_INT / 10 &amp;&amp; c &gt; MAX_INT % 10)))&#123;</div><div class="line">                    ans = MAX_INT;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                else if (sign &lt; 0 &amp;&amp; (ans &gt; (unsigned)MIN_INT / 10 || (ans == (unsigned)MIN_INT / 10 &amp;&amp; c &gt; (unsigned)MIN_INT % 10)))&#123;</div><div class="line">                    ans = MIN_INT;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                ans = ans * 10 + c;</div><div class="line">                temp++;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return sign &gt; 0 ? ans : -ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值而”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><strong>Input：</strong></p>
<p>“+100”</p>
<p><strong>Output：</strong></p>
<p>True</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题是要设计一个正则表达式能够判断字符的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import re</div><div class="line">class Solution:</div><div class="line">    # s字符串</div><div class="line">    def isNumeric(self, s):</div><div class="line">        # write code here</div><div class="line">        return re.match(&quot;^[+-]?\\d*(\\.\\d+)?([Ee][+-]?\\d+)?$&quot;, s)</div></pre></td></tr></table></figure>
<h3 id="字符流中第一次只出现一次的字符"><a href="#字符流中第一次只出现一次的字符" class="headerlink" title="字符流中第一次只出现一次的字符"></a>字符流中第一次只出现一次的字符</h3><p>题目：请实现一个函数用来找出字符流中第一个只出现一次的字符。<br><strong>Input：</strong></p>
<p>google</p>
<p><strong>Output：</strong></p>
<p>l</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题使用hash的方式统计次数，需要注意的是需要得到的是第一次出现的单一字符，因此需要从头到尾判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # 返回对应char</div><div class="line">    def __init__(self):</div><div class="line">        self.dic = &#123;&#125;</div><div class="line">        self.s = &quot;&quot;</div><div class="line">    def FirstAppearingOnce(self):</div><div class="line">        # write code here</div><div class="line">        for i in self.s:</div><div class="line">            if self.dic[i] == 1:</div><div class="line">                return i</div><div class="line">        return &apos;#&apos;</div><div class="line">    def Insert(self, char):</div><div class="line">        # write code here</div><div class="line">        self.s += char</div><div class="line">        if char in self.dic:</div><div class="line">            self.dic[char] += 1</div><div class="line">        else:</div><div class="line">            self.dic[char] = 1</div></pre></td></tr></table></figure>
<h2 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h2><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>Input：</strong></p>
<p>7, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</p>
<p><strong>Output：</strong></p>
<p>True</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 既然二维数组满足严格的递增关系，那么我们可以考虑从数组的一个极端值开始考虑。以左下角为例，row = len(array)-1，col = 0的点比同一个col的其他值都大，因此如果此时这个数比我们的目标要大，我们只需要向上寻找即可。寻找过程中如果出现当前数字小于目标的时候，尝试往右寻找。如此往复，直到无路可走为止。想法类似<strong>DFS</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # array 二维列表</div><div class="line">    def Find(self, target, array):</div><div class="line">        # write code here</div><div class="line">        if not array[0]:</div><div class="line">            return False</div><div class="line">        row = len(array)-1</div><div class="line">        col = 0</div><div class="line">        while (row &gt;=0) and (col &lt; len(array[0])):</div><div class="line">            if array[row][col] == target:</div><div class="line">                return True</div><div class="line">            elif array[row][col] &gt; target:</div><div class="line">                row-=1</div><div class="line">            else:</div><div class="line">                col+=1</div><div class="line">        return False</div></pre></td></tr></table></figure>
<h3 id="调整数组顺序让基数位于偶数前面"><a href="#调整数组顺序让基数位于偶数前面" class="headerlink" title="调整数组顺序让基数位于偶数前面"></a>调整数组顺序让基数位于偶数前面</h3><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><strong>Input：</strong></p>
<p>[1,2,3,4,5,6,7]</p>
<p><strong>Output：</strong></p>
<p>[1,3,5,7,2,4,6]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 利用两个指针来表示新数组中奇数和偶数的位置，然后依次插入即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def reOrderArray(self, array):</div><div class="line">        # write code here</div><div class="line">        if len(array) == 0:</div><div class="line">            return []</div><div class="line">        new_list = []</div><div class="line">        temp = 0</div><div class="line">        for i in array:</div><div class="line">            if i % 2 == 0:</div><div class="line">                new_list.append(i)</div><div class="line">            else:</div><div class="line">                new_list.insert(temp, i)</div><div class="line">                temp += 1</div><div class="line">        return new_list</div></pre></td></tr></table></figure>
<h3 id="数组中最小的k个数"><a href="#数组中最小的k个数" class="headerlink" title="数组中最小的k个数"></a>数组中最小的k个数</h3><p>题目：输入n个整数，找出其中最小的K个数。<br><strong>Input：</strong></p>
<p>{4,5,1,6,2,7,3,8}， 4</p>
<p><strong>Output：</strong></p>
<p>[1,2,3,4]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题是经典的算法题之一，其思路多种多样。其中包括最基本的排序取前k个数；维护一个长度为k的最小堆以及BFPRT算法（利用中位数进行更精准的二分）等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def is_min(self, s, k):</div><div class="line">        temp = s[-1]</div><div class="line">        if k &lt; temp:</div><div class="line">            s[-1] = k</div><div class="line">        s = sorted(s)</div><div class="line">        return s</div><div class="line">    def GetLeastNumbers_Solution(self, tinput, k):</div><div class="line">        # write code here</div><div class="line">        if k == len(tinput):</div><div class="line">            return sorted(tinput)</div><div class="line">        if k == 0 or not tinput or k &gt; len(tinput):</div><div class="line">            return []</div><div class="line">        min_heap = []</div><div class="line">        for i in range(k):</div><div class="line">            min_heap.append(tinput[i])</div><div class="line">        min_heap = sorted(min_heap)</div><div class="line">        for i in range(k, len(tinput)):</div><div class="line">            min_heap = self.is_min(min_heap, tinput[i])</div><div class="line">        return min_heap</div></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><p>题目：HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<br><strong>Input：</strong></p>
<p>{6,-3,-2,7,-15,1,2,2}</p>
<p><strong>Output：</strong></p>
<p>8</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本体求的是连续数组，可以使用循环或者动态规划的思维来解决。其核心就是在遍历数组的过程中维护两个值，其中一个记录当前的和，另一个记录最大和。当当前和大于0且大于最大和的时候，更新最大和；如果当前和小于零，则令当前和等于下一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def FindGreatestSumOfSubArray(self, array):</div><div class="line">        # write code here</div><div class="line">        if len(array) == 0:</div><div class="line">            return 0</div><div class="line">        ans = array[0]</div><div class="line">        cur = 0</div><div class="line">        for i in range(len(array)):</div><div class="line">            if cur &lt; 0:</div><div class="line">                cur = array[i]</div><div class="line">            else:</div><div class="line">                cur += array[i]</div><div class="line">            if cur &gt; ans:</div><div class="line">                ans = cur</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br><strong>Input：</strong></p>
<p>{3，32，321}</p>
<p><strong>Output：</strong></p>
<p>321323</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题使用贪心（Greedy）算法和DFS结合的思路按照从长到短的顺序判断左右拼接字符的大小，然后选择大的继续。注意从长到短是因为长的数对全局影响比较大，用大的拼接小的可变化范围会增加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def PrintMinNumber(self, numbers):</div><div class="line">        # write code here</div><div class="line">        if len(numbers) == 0:</div><div class="line">            return &quot;&quot;</div><div class="line">        ans = &quot;&quot;</div><div class="line">        numbers = sorted(numbers)</div><div class="line">        for i in range(len(numbers)):</div><div class="line">            ans1 = int(ans + str(numbers[i]))</div><div class="line">            ans2 = int(str(numbers[i]) + ans)</div><div class="line">            if ans1 &gt; ans2:</div><div class="line">                ans = str(ans2)</div><div class="line">            else:</div><div class="line">                ans = str(ans1)</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>题目：把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><strong>Input：</strong></p>
<p>2</p>
<p><strong>Output：</strong></p>
<p>2</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题如果使用遍历实数域的方式很难实现，所以可以考虑对因数进行组合。因为丑数是只包含2、3和5的因数，因此其值可以表示为 <strong>2i+3j+5k</strong> 的形式，因此我们去匹配相应的i、j、k系数，取组合数的最小值作为下一个出现的丑数，从而找到结果。注意：一次只加i、j、k中的一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def GetUglyNumber_Solution(self, index):</div><div class="line">        # write code here</div><div class="line">        if index == 0:</div><div class="line">            return 0</div><div class="line">        if index == 1:</div><div class="line">            return 1</div><div class="line">        l = [1]</div><div class="line">        idx_two = 0</div><div class="line">        idx_three = 0</div><div class="line">        idx_five = 0</div><div class="line">        for _ in range(index-1):</div><div class="line">            temp = min(l[idx_two]*2, l[idx_three]*3, l[idx_five]*5)</div><div class="line">            l.append(temp)</div><div class="line">            if temp % 2 == 0:</div><div class="line">                idx_two += 1</div><div class="line">            if temp % 3 == 0:</div><div class="line">                idx_three += 1</div><div class="line">            if temp % 5 == 0:</div><div class="line">                idx_five += 1</div><div class="line">        return l[-1]</div></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h3><p>题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><strong>Input：</strong></p>
<p>[2,4,3,6,3,2,5,5]</p>
<p><strong>Output：</strong></p>
<p>“4,6”</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 利用hash和字典可以轻松解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # 返回[a,b] 其中ab是出现一次的两个数字</div><div class="line">    def FindNumsAppearOnce(self, array):</div><div class="line">        # write code here</div><div class="line">        if len(array) == 0:</div><div class="line">            return</div><div class="line">        ans = []</div><div class="line">        dic = &#123;i : 0 for i in array&#125;</div><div class="line">        for i in array:</div><div class="line">            dic[i] += 1</div><div class="line">        for i, j in dic.items():</div><div class="line">            if j == 1:</div><div class="line">                ans.append(i)</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><strong>Input：</strong></p>
<p>[2,1,3,1,4]</p>
<p><strong>Output：</strong></p>
<p>“true, 1”</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 利用一个bool数组来动态规划。原本所有的数字table都为false，如果某一个数字对应数值位置的值为true，表示该数字已经出现过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    // Parameters:</div><div class="line">    //    numbers:     an array of integers</div><div class="line">    //    length:      the length of array numbers</div><div class="line">    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</div><div class="line">    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</div><div class="line">    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]</div><div class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</div><div class="line">    //                     otherwise false</div><div class="line">    public boolean duplicate(int numbers[],int length,int [] duplication) &#123;</div><div class="line">        boolean temp[] = new boolean[length];</div><div class="line">        for (int i = 0; i &lt; length; i++)&#123;</div><div class="line">            if (temp[numbers[i]] == true) &#123;</div><div class="line">                duplication[0] = numbers[i];</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            temp[numbers[i]] = true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="栈和堆叠（stack-amp-heap）"><a href="#栈和堆叠（stack-amp-heap）" class="headerlink" title="栈和堆叠（stack &amp; heap）"></a>栈和堆叠（stack &amp; heap）</h2><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><strong>Input：</strong></p>
<p>[1, 2, 3, “POP”, “POP”, 4, “POP”, 5, “POP”, “POP”]</p>
<p><strong>Output：</strong></p>
<p>1,2,3,4,5</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 栈的特点是先进后出，如果要让栈内元素先进先出，就必须使用另一个栈来接它pop出去的元素，利用第二个栈的顺序依次pop即为队列（queue）的顺序。此外要注意的是，在pop结束之后，如果第二个栈内有剩余的元素，需要将这些元素pop回第一个栈再继续push的动作，这样才能保证元素的顺序正确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pop() &#123;</div><div class="line">        while (!stack1.empty())&#123;</div><div class="line">            stack2.push(stack1.top());</div><div class="line">            stack1.pop();</div><div class="line">        &#125;</div><div class="line">        int ans = stack2.top();</div><div class="line">        stack2.pop();</div><div class="line">        while (!stack2.empty())&#123;</div><div class="line">            stack1.push(stack2.top());</div><div class="line">            stack2.pop();</div><div class="line">        &#125;</div><div class="line">        return ans;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br><strong>Input：</strong></p>
<p>[3, “MIN”, 4, “MIN”, 2, “MIN”, 3, “MIN”, “POP”, “MIN”, “POP”, “MIN”, “POP”, “MIN”, 0, “MIN”]</p>
<p><strong>Output：</strong></p>
<p>3,3,2,2,2,3,3,0</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题考察数据结构的实作，在stack的基础上实现判断最小值的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def __init__(self):</div><div class="line">        self.stack = []</div><div class="line">    def push(self, node):</div><div class="line">        # write code here</div><div class="line">        self.stack.append(node)</div><div class="line">    def pop(self):</div><div class="line">        # write code here</div><div class="line">        if self.stack:</div><div class="line">            del self.stack[-1]</div><div class="line">    def top(self):</div><div class="line">        # write code here</div><div class="line">        if self.stack:</div><div class="line">            return self.stack[-1]</div><div class="line">    def min(self):</div><div class="line">        # write code here</div><div class="line">        self.min_stack = []</div><div class="line">        if self.stack:</div><div class="line">            min = self.stack[-1]</div><div class="line">        else:</div><div class="line">            min = 0</div><div class="line">        while self.stack:</div><div class="line">            temp = self.top()</div><div class="line">            self.min_stack.append(temp)</div><div class="line">            self.pop()</div><div class="line">            if temp &lt; min:</div><div class="line">                min = temp</div><div class="line">        self.stack = self.min_stack[::-1]</div><div class="line">        return min</div></pre></td></tr></table></figure>
<h3 id="栈的压入与弹出序列"><a href="#栈的压入与弹出序列" class="headerlink" title="栈的压入与弹出序列"></a>栈的压入与弹出序列</h3><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br><strong>Input：</strong></p>
<p>[1,2,3,4,5], [4,3,5,1,2]</p>
<p><strong>Output：</strong></p>
<p>False</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 利用DFS的思路可以对pushV和popV里面所有时刻的值进行对比，判断是否能够组成一条完整的输出路线即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def IsPopOrder(self, pushV, popV):</div><div class="line">        # write code here</div><div class="line">        if not pushV or len(pushV) != len(popV):</div><div class="line">            return False</div><div class="line">        stack = []</div><div class="line">        for i in range(len(pushV)):</div><div class="line">            stack.append(pushV[i])</div><div class="line">            while stack and popV[0] == stack[-1]:</div><div class="line">                stack.pop()</div><div class="line">                popV.pop(0)</div><div class="line">        if len(stack) != 0:</div><div class="line">            return False</div><div class="line">        return True</div></pre></td></tr></table></figure>
<h1 id="智力题和知识迁移"><a href="#智力题和知识迁移" class="headerlink" title="智力题和知识迁移"></a>智力题和知识迁移</h1><h2 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a>矩阵覆盖</h2><p>题目：我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2<em>n的大矩形，总共有多少种方法？<br><em>*Input：</em></em></p>
<p>4</p>
<p><strong>Output：</strong></p>
<p>5</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> t时刻的状态可以由t-1时刻的状态加上一个2<em>1的小矩阵构成，因此不难想到利用状态转移的方式进行解答。由于是2</em>1的矩阵，因此在扩展2<em>n大矩阵的时候可能出现 <strong>‘||’</strong> 和 <em>*’=’</em></em> 两种摆放形式，而这要求下矩阵需要以偶数形式出现。因此不难想到状态在偶数时会比奇数时多，一个典型的斐波那契数列应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def rectCover(self, number):</div><div class="line">        # write code here</div><div class="line">        if number &lt; 1:</div><div class="line">            return 0</div><div class="line">        if number == 1:</div><div class="line">            return 1</div><div class="line">        ans = 1</div><div class="line">        a = 1</div><div class="line">        for i in range(2, number + 1):</div><div class="line">            temp = ans</div><div class="line">            ans += a</div><div class="line">            a = temp</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br><strong>Input：</strong></p>
<p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</p>
<p><strong>Output：</strong></p>
<p>1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p>
<p><strong>Requirement：</strong> 本体考察空间想象能力，通过每次将二维阵列的第一行从左到右顺序打印，然后删除打印的元素。之后对阵列进行倒序转置，一次往复就能够实现螺旋打印了。</p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本体需要考虑的问题是打印的顺序属于动态变化的情况，因此我们采用动态阵列的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # matrix类型为二维列表，需要返回列表</div><div class="line">    def transform(self, matrix):</div><div class="line">        n = len(matrix)</div><div class="line">        m = len(matrix[0])</div><div class="line">        B = []</div><div class="line">        for i in range(m):</div><div class="line">            A = []</div><div class="line">            for j in range(n):</div><div class="line">                A.append(matrix[j][i])</div><div class="line">            B.append(A)</div><div class="line">        return B[::-1]</div><div class="line">    def printMatrix(self, matrix):</div><div class="line">        # write code here</div><div class="line">        result = []</div><div class="line">        while matrix:</div><div class="line">            result += matrix.pop(0)</div><div class="line">            if not matrix:</div><div class="line">                break</div><div class="line">            matrix = self.transform(matrix)</div><div class="line">        return result</div></pre></td></tr></table></figure>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空。<br><strong>Input：</strong></p>
<p>{1,2,3,4,5,3,5,’#’,2,’#’}</p>
<p><strong>Output：</strong></p>
<p>{1,2,3,4,5,3,5,’#’,2,’#’}</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 该题可以利用几种不同的思路进行解答，其中包括先利用临时阵列存取所有node的random值，然后复制原先的阵列，再将random值顺序赋值给对应的node。另一种是将遍历的每一个node复制到它的next结点，然后通过跳过一次的方式提取偶数node作为复制后的链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class RandomListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.label = x</div><div class="line">#         self.next = None</div><div class="line">#         self.random = None</div><div class="line">class Solution:</div><div class="line">    # 返回 RandomListNode</div><div class="line">    def Build(self, pHead):</div><div class="line">        temp = []</div><div class="line">        while pHead:</div><div class="line">            ans = pHead.random</div><div class="line">            temp.append(ans)</div><div class="line">            pHead = pHead.next</div><div class="line">        return temp</div><div class="line">    def Clone(self, pHead):</div><div class="line">        # write code here</div><div class="line">        if not pHead:</div><div class="line">            return</div><div class="line">        temp = self.Build(pHead)</div><div class="line">        root = pHead</div><div class="line">        res = RandomListNode(root.label)</div><div class="line">        result = res</div><div class="line">        result2 = res</div><div class="line">        while root.next:</div><div class="line">            root = root.next</div><div class="line">            newNode = RandomListNode(root.label)</div><div class="line">            result.next = newNode</div><div class="line">            result = result.next</div><div class="line">        for i in temp:</div><div class="line">            result2.random = i</div><div class="line">            result2 = result2.next</div><div class="line">        return res</div></pre></td></tr></table></figure>
<h2 id="二叉检索树转换成双向链表"><a href="#二叉检索树转换成双向链表" class="headerlink" title="二叉检索树转换成双向链表"></a>二叉检索树转换成双向链表</h2><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><strong>Input：</strong></p>
<p>{10,6,14,4,8,12,16}</p>
<p><strong>Output：</strong></p>
<p>From left to right are: 4,6,8,10,12,14,16; From right to left are: 16,14,12,10,8,6,4;</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题主要考察的是对数据结构的熟悉程度以及利用深度优先检索的中续遍历来构建双向链表的思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def Convert(self, pRootOfTree):</div><div class="line">        # write code here</div><div class="line">        if not pRootOfTree:</div><div class="line">            return None</div><div class="line">        stack = []</div><div class="line">        flag = True</div><div class="line">        root = pRootOfTree</div><div class="line">        while root or len(stack) != 0:</div><div class="line">            while root:</div><div class="line">                stack.append(root)</div><div class="line">                root = root.left</div><div class="line">            root = stack.pop()</div><div class="line">            if flag:</div><div class="line">                pRootOfTree = root</div><div class="line">                pre = root</div><div class="line">                flag = False</div><div class="line">            else:</div><div class="line">                pre.right = root</div><div class="line">                root.left = pre</div><div class="line">                pre = root</div><div class="line">            root = root.right</div><div class="line">        return pRootOfTree</div></pre></td></tr></table></figure>
<h2 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h2><p>题目：求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br><strong>Input：</strong></p>
<p>10</p>
<p><strong>Output：</strong></p>
<p>2</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。<br>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100-199，1100-1199,2100-2199，，…，11100-11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。<br>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100-199，1100-1199,2100-2199，，….，11100-11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100-12113,一共114个，等于低位数字（113）+1。<br>③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100-199,1100-1199，2100-2199，…，11100-11199,12100-12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def NumberOf1Between1AndN_Solution(self, n):</div><div class="line">        # write code here</div><div class="line">        ans = 0</div><div class="line">        temp = 1</div><div class="line">        cand = n</div><div class="line">        while cand:</div><div class="line">            last = cand % 10</div><div class="line">            cand = cand // 10</div><div class="line">            ans += cand * temp</div><div class="line">            if last == 1:</div><div class="line">                ans += n % temp + 1</div><div class="line">            elif last &gt; 1:</div><div class="line">                ans += temp</div><div class="line">            temp *= 10</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h2 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h2><p>题目：LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。<br><strong>Input：</strong></p>
<p>[1,3,2,5,4]</p>
<p><strong>Output：</strong></p>
<p>true</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题比起正向思考，反向考虑其矛盾点更为明智。首先需要组成顺子必须保证有5张牌，其次如果5张牌有王，就必须保证除了王之外的数相差不超过5。同时不能有重复的出现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def is_same(self, s, i, k):</div><div class="line">        for i in range(i, k-1):</div><div class="line">            temp = s[i]</div><div class="line">            for j in range(i+1, k):</div><div class="line">                if s[j] == temp:</div><div class="line">                    return True</div><div class="line">        return False</div><div class="line">    def IsContinuous(self, numbers):</div><div class="line">        # write code here</div><div class="line">        if len(numbers) != 5:</div><div class="line">            return False</div><div class="line">        num = sorted(numbers)</div><div class="line">        point = 0</div><div class="line">        if num[-1] == 0:</div><div class="line">            return False</div><div class="line">        while num[point] == 0:</div><div class="line">            point += 1</div><div class="line">        if point != len(num) - 1:</div><div class="line">            if self.is_same(num, point, len(num)):</div><div class="line">                return False</div><div class="line">            if num[-1] - num[point] &gt;= 5:</div><div class="line">                return False</div><div class="line">        return True</div></pre></td></tr></table></figure>
<h2 id="孩子们的游戏（环中剩下的数）"><a href="#孩子们的游戏（环中剩下的数）" class="headerlink" title="孩子们的游戏（环中剩下的数）"></a>孩子们的游戏（环中剩下的数）</h2><p>题目：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)。<br><strong>Input：</strong></p>
<p>5, 3</p>
<p><strong>Output：</strong></p>
<p>3</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题可以使用递归的思路解答，最后的胜利者永远不变，可以不断添加失败者进行递归的动作。另一种解法就是把环当成一个数组，然后根据规则每次删除数组中的相应的元素，最后的元素就是胜利者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def LastRemaining_Solution(self, n, m):</div><div class="line">        # write code here</div><div class="line">        if n == 0 or m &lt; 0:</div><div class="line">            return -1</div><div class="line">        temp = 0</div><div class="line">        ans = range(n)</div><div class="line">        while len(ans) &gt; 1:</div><div class="line">            temp = (temp + m - 1) % len(ans)</div><div class="line">            ans.pop(temp)</div><div class="line">        return ans[0]</div></pre></td></tr></table></figure>
<h2 id="1-2-3-4-…-n"><a href="#1-2-3-4-…-n" class="headerlink" title="1+2+3+4+…+n"></a>1+2+3+4+…+n</h2><p>题目：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><strong>Input：</strong></p>
<p>1+2+3</p>
<p><strong>Output：</strong></p>
<p>6</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题的难点在于无法使用判断退出循环。因此可以使用位操作符的特性来进行判断，大于小于作为bool值返回的时候可以作为判断条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def __init__(self):</div><div class="line">        self.sum = 0</div><div class="line">    def Sum_Solution(self, n):</div><div class="line">        # write code here</div><div class="line">        def func(n):</div><div class="line">            self.sum += n</div><div class="line">            n -= 1</div><div class="line">            return n &gt; 0 and self.Sum_Solution(n)</div><div class="line">        func(n)</div><div class="line">        return self.sum</div></pre></td></tr></table></figure>
<h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。<br><strong>Input：</strong></p>
<p>[1,2,3,4,5]</p>
<p><strong>Output：</strong></p>
<p>[120,60,40,30,24]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> B数组中的值就是A数组的值去掉i对应的哪一项后的乘积。不能使用除法的情况下，我们就可以使用动态规划，维护一个A*B的二维阵列，其中对应Ai = Bi的值全为1，然后计算整个阵列每行的乘积和即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def multiply(self, A):</div><div class="line">        # write code here</div><div class="line">        B = [1 for _ in range(len(A))]</div><div class="line">        for i in range(1, len(A)):</div><div class="line">            B[i] = B[i - 1] * A[i - 1]</div><div class="line">        temp = 1</div><div class="line">        for j in range(len(A) - 2, -1, -1):</div><div class="line">            temp *= A[j + 1]</div><div class="line">            B[j] *= temp</div><div class="line">        return B</div></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>题目：请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab<em>a”均不匹配。<br><em>*Input：</em></em></p>
<p>“aa”, “aa”</p>
<p><strong>Output：</strong></p>
<p>true</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题的思路是递归加DFS。需要考虑的情况包括。如果下一个字符是’<em>‘，则当前的值如果是’.’或者与匹配字符相等，则继续判断三种情况：1、匹配字符跳过与当前正则表达式的字符继续匹配；2、跳过正则表达式的当前字符和’</em>‘，继续和匹配字符的当前字符比较；3、跳过正则表达式的当前字符和’<em>‘同时跳过匹配字符的当前字符，匹配双方的下一个字符。这三种情况有一种成立即可继续。另外，如果’</em>‘前面的字符不匹配，则跳过’<em>‘继续匹配。如果下一个字符不是’</em>‘，则匹配当前字符是否为’.’或者匹配字符，如果是跳过双方继续。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # s, pattern都是字符串</div><div class="line">    def match(self, s, pattern):</div><div class="line">        # write code here</div><div class="line">        if len(s) == 0 and len(pattern) == 0:</div><div class="line">            return True</div><div class="line">        if len(s) &gt; 0 and len(pattern) == 0:</div><div class="line">            return False</div><div class="line">        if len(pattern) &gt; 1 and pattern[1] == &apos;*&apos;:</div><div class="line">            if len(s) &gt; 0 and (pattern[0] == &apos;.&apos; or pattern[0] == s[0]):</div><div class="line">                return self.match(s, pattern[2:]) or self.match(s[1:], pattern) or self.match(s[1:], pattern[2:])</div><div class="line">            else:</div><div class="line">                return self.match(s, pattern[2:])</div><div class="line">        else:</div><div class="line">            if len(s) &gt; 0 and (pattern[0] == &apos;.&apos; or pattern[0] == s[0]):</div><div class="line">                return self.match(s[1:], pattern[1:])</div><div class="line">        return False</div></pre></td></tr></table></figure>
<h2 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h2><p>题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><strong>Input：</strong></p>
<p>{8,6,10,5,7,9,11}</p>
<p><strong>Output：</strong></p>
<p>[[8], [10,6], [5,7,9,11]]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题的思路就是在二叉树的广度优先检索（BFS）算法的基础上加上了一些变形，维护一个flag来判断当前是顺序打印还是逆序打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def Print(self, pRoot):</div><div class="line">        # write code here</div><div class="line">        if not pRoot:</div><div class="line">            return []</div><div class="line">        res, temp = [], []</div><div class="line">        last = pRoot</div><div class="line">        queue = [pRoot]</div><div class="line">        flag = True</div><div class="line">        while queue:</div><div class="line">            cand = queue.pop(0)</div><div class="line">            temp.append(cand.val)</div><div class="line">            if cand.left:</div><div class="line">                queue.append(cand.left)</div><div class="line">            if cand.right:</div><div class="line">                queue.append(cand.right)</div><div class="line">            if cand == last:</div><div class="line">                res.append(temp if flag else temp[::-1])</div><div class="line">                flag = not flag</div><div class="line">                temp = []</div><div class="line">                if queue:</div><div class="line">                    last = queue[-1]</div><div class="line">        return res</div></pre></td></tr></table></figure>
<h2 id="序列化和反序列化二叉树"><a href="#序列化和反序列化二叉树" class="headerlink" title="序列化和反序列化二叉树"></a>序列化和反序列化二叉树</h2><p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。<br><strong>Input：</strong></p>
<p>{8,6,10,5,#,9,11}</p>
<p><strong>Output：</strong></p>
<p>{8,6,10,5,#,9,11}</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 序列化二叉树就是用一个数据结构来表示二叉树，最简单的就是利用字符串以’,’区隔树的每一个node，然后用’#’表示空，按照从左到右的顺序编码。解码的时候就是编码的逆序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def __init__(self):</div><div class="line">        self.idx = -1</div><div class="line">    def Serialize(self, root):</div><div class="line">        # write code here</div><div class="line">        if not root:</div><div class="line">            return &apos;#&apos;</div><div class="line">        return str(root.val) + &apos;,&apos; + self.Serialize(root.left) + &apos;,&apos; + self.Serialize(root.right)</div><div class="line">    def Deserialize(self, s):</div><div class="line">        # write code here</div><div class="line">        temp = s.split(&apos;,&apos;)</div><div class="line">        self.idx += 1</div><div class="line">        if temp[self.idx] == &apos;#&apos;:</div><div class="line">            return None</div><div class="line">        root = TreeNode(int(temp[self.idx]))</div><div class="line">        root.left = self.Deserialize(s)</div><div class="line">        root.right = self.Deserialize(s)</div><div class="line">        return root</div></pre></td></tr></table></figure>
<h2 id="滚动窗口的最大值"><a href="#滚动窗口的最大值" class="headerlink" title="滚动窗口的最大值"></a>滚动窗口的最大值</h2><p>题目：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br><strong>Input：</strong></p>
<p>[2,3,4,2,6,2,5,1], 3</p>
<p><strong>Output：</strong></p>
<p>[4,4,6,6,6,5]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题的关键信息在于window的size，我们可以维护一个window大小的数组，然后从左往右判断第一个数是否是最大的，如果此时长度已经达到了size的要求，那么pop第一个数，数组右移加入新的成员；或者如果数组中有数比第一个元素大则pop左边元素（目的是保证数组最左边的数永远最大）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def is_max(self, deque):</div><div class="line">        temp = deque[0]</div><div class="line">        for j in range(1, len(deque)):</div><div class="line">            if temp &lt;= deque[j]:</div><div class="line">                return True</div><div class="line">        return False</div><div class="line">    def process(self, num, deque, size):</div><div class="line">        while len(deque) &gt; size or self.is_max(deque):</div><div class="line">            deque.pop(0)</div><div class="line">            if len(deque) == 1:</div><div class="line">                break</div><div class="line">        return deque</div><div class="line">    def maxInWindows(self, num, size):</div><div class="line">        # write code here</div><div class="line">        ans = []</div><div class="line">        if len(num) == 0 or len(num) &lt; size or size == 0:</div><div class="line">            return []</div><div class="line">        deque = num[:size-1]</div><div class="line">        for i in range(size-1, len(num)):</div><div class="line">            deque.append(num[i])</div><div class="line">            temp = self.process(num, deque, size)</div><div class="line">            ans.append(temp[0])</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><p>题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><strong>Input：</strong></p>
<p>5, 10, 10</p>
<p><strong>Output：</strong></p>
<p>21</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题是一个深度检索和动态规划的结合应用，利用维护一个阵列来动态判断每一个格子的可能性，然后利用深度检索的方式便利空间图形中的所有格子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def __init__(self):</div><div class="line">        self.count = 0</div><div class="line">    def move(self, matrix, threshold, rows, cols, i, j):</div><div class="line">        if not (0&lt;=i&lt;rows and 0&lt;=j&lt;cols):</div><div class="line">            return</div><div class="line">        temp = sum(map(int, str(i) + str(j)))</div><div class="line">        if matrix[i][j] == -1 or temp &gt; threshold:</div><div class="line">            matrix[i][j] = -1</div><div class="line">            return</div><div class="line">        if matrix[i][j] == 1:</div><div class="line">            return</div><div class="line">        matrix[i][j] = 1</div><div class="line">        self.count += 1</div><div class="line">        self.move(matrix, threshold, rows, cols, i+1, j)</div><div class="line">        self.move(matrix, threshold, rows, cols, i-1, j)</div><div class="line">        self.move(matrix, threshold, rows, cols, i, j+1)</div><div class="line">        self.move(matrix, threshold, rows, cols, i, j-1)</div><div class="line">    def movingCount(self, threshold, rows, cols):</div><div class="line">        # write code here</div><div class="line">        matrix = [[0 for _ in range(cols)] for _ in range(rows)]</div><div class="line">        self.move(matrix, threshold, rows, cols, 0, 0)</div><div class="line">        return self.count</div></pre></td></tr></table></figure>
<h1 id="基本算法和逻辑"><a href="#基本算法和逻辑" class="headerlink" title="基本算法和逻辑"></a>基本算法和逻辑</h1><h2 id="递归和循环（recursive-amp-recurrent）"><a href="#递归和循环（recursive-amp-recurrent）" class="headerlink" title="递归和循环（recursive &amp; recurrent）"></a>递归和循环（recursive &amp; recurrent）</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）<br><strong>Input：</strong></p>
<p>4</p>
<p><strong>Output：</strong></p>
<p>3</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 斐波那契数列的性质来看，通过循环或者动态规划可以轻松实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def Fibonacci(self, n):</div><div class="line">        # write code here</div><div class="line">        if n &lt;= 0:</div><div class="line">            return 0</div><div class="line">        ans = 1</div><div class="line">        pre = 1</div><div class="line">        while n &gt; 2:</div><div class="line">            temp = ans</div><div class="line">            ans = ans + pre</div><div class="line">            pre = temp</div><div class="line">            n-=1</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="普通跳台阶问题"><a href="#普通跳台阶问题" class="headerlink" title="普通跳台阶问题"></a>普通跳台阶问题</h3><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>Input：</strong></p>
<p>4</p>
<p><strong>Output：</strong></p>
<p>5</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 斐波那契数列的简单应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def jumpFloor(self, number):</div><div class="line">        # write code here</div><div class="line">        if number == 1:</div><div class="line">            return 1</div><div class="line">       	if number == 2:</div><div class="line">            return 2</div><div class="line">        a1 = 1</div><div class="line">        a2 = 2</div><div class="line">        ans = 0</div><div class="line">        for i in range(3, number+1):</div><div class="line">            ans = a1 + a2</div><div class="line">            a1 = a2</div><div class="line">            a2 = ans</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="跳台阶进阶问题"><a href="#跳台阶进阶问题" class="headerlink" title="跳台阶进阶问题"></a>跳台阶进阶问题</h3><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>Input：</strong></p>
<p>2</p>
<p><strong>Output：</strong></p>
<p>2</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 不同与普通跳台阶问题，状态的转移关系到之前所有的状态累加。因此考虑t+1的状态可以表示成t状态的转移量，即1~t-1所有状态到t状态的可能性加上t到t+1状态的可能性。我们用ans表示X状态下对应的说有可能性，则t+1时刻的ans = t时刻的ans + （1~t-1）时刻的ans，而1~t-1时刻的ans又 = t时刻的ans。因此t+1时刻的ans = 2*t时刻的ans。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def jumpFloorII(self, number):</div><div class="line">        # write code here</div><div class="line">        ans = 1</div><div class="line">        for i in range(2, number + 1):</div><div class="line">            ans += ans</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><p>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><strong>Input：</strong></p>
<p>2, 3</p>
<p><strong>Output：</strong></p>
<p>8.00000</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题如果用python的pow function可以轻易实现，如果使用循环的方式则属于考察临界条件的连乘问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def Power(self, base, exponent):</div><div class="line">        # write code here</div><div class="line">        ans = 1</div><div class="line">        if base == 0:</div><div class="line">            return 0</div><div class="line">        temp = exponent</div><div class="line">        if exponent &lt; 0:</div><div class="line">            temp = -exponent</div><div class="line">        while temp != 0:</div><div class="line">            ans *= base</div><div class="line">            temp -= 1</div><div class="line">        return ans if exponent &gt;= 0 else 1/ans</div></pre></td></tr></table></figure>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>题目：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><strong>Input：</strong></p>
<p>{1,2,3,4,5,#,6,#,#,7}</p>
<p><strong>Output：</strong></p>
<p>4</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 典型的递归问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    def TreeDepth(self, pRoot):</div><div class="line">        # write code here</div><div class="line">        if not pRoot:</div><div class="line">            return 0</div><div class="line">        left = self.TreeDepth(pRoot.left)</div><div class="line">        right = self.TreeDepth(pRoot.right)</div><div class="line">        return max(left+1, right+1)</div></pre></td></tr></table></figure>
<h3 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h3><p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br><strong>Input：</strong></p>
<p>{1,2,3,3,4,4,5}</p>
<p><strong>Output：</strong></p>
<p>{1,2,5}</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题可以使用递归的思路解决，可以使用两个指针分别遍历链表，如果下一个指针和当前指针相同的话则跳过后者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def deleteDuplication(self, pHead):</div><div class="line">        # write code here</div><div class="line">        if not pHead or not pHead.next:</div><div class="line">            return pHead</div><div class="line">        temp = pHead.next</div><div class="line">        if temp.val != pHead.val:</div><div class="line">            pHead.next = self.deleteDuplication(temp)</div><div class="line">        else:</div><div class="line">            while pHead.val == temp.val and temp.next:</div><div class="line">                temp = temp.next</div><div class="line">            if temp.val != pHead.val:</div><div class="line">                pHead = self.deleteDuplication(temp)</div><div class="line">            else:</div><div class="line">                return None</div><div class="line">        return pHead</div></pre></td></tr></table></figure>
<h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><strong>Input：</strong></p>
<p>“ABCESFCSADEE”, 3, 4, “ABCCED”</p>
<p><strong>Output：</strong></p>
<p>true</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 3s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题是典型的DFS应用在Graph上的例子，在空间二维字符表中进行深度检索，利用动态规划的方式确定答案是否存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def search(self, matrix, rows, cols, path, i, j):</div><div class="line">        if not path:</div><div class="line">            return True</div><div class="line">        matrix[i*cols + j] = -1</div><div class="line">        if j+1&lt;cols and matrix[i*cols+j+1] == path[0]:</div><div class="line">            return self.search(matrix, rows, cols, path[1:], i, j+1)</div><div class="line">        elif j-1&gt;=0 and matrix[i*cols+j-1] == path[0]:</div><div class="line">            return self.search(matrix, rows, cols, path[1:], i, j-1)</div><div class="line">        elif i+1&lt;rows and matrix[(i+1)*cols+j] == path[0]:</div><div class="line">            return self.search(matrix, rows, cols, path[1:], i+1, j)</div><div class="line">        elif i-1&gt;=0 and matrix[(i-1)*cols+j] == path[0]:</div><div class="line">            return self.search(matrix, rows, cols, path[1:], i-1, j)</div><div class="line">        else:</div><div class="line">            return False</div><div class="line">    def hasPath(self, matrix, rows, cols, path):</div><div class="line">        # write code here</div><div class="line">        if not path or not matrix:</div><div class="line">            return False</div><div class="line">        for i in range(rows):</div><div class="line">            for j in range(cols):</div><div class="line">                if matrix[i*cols + j] == path[0]:</div><div class="line">                    if self.search(list(matrix), rows, cols, path[1:], i, j):</div><div class="line">                        return True</div><div class="line">        return False</div></pre></td></tr></table></figure>
<h2 id="查找和排序（search-amp-sort）"><a href="#查找和排序（search-amp-sort）" class="headerlink" title="查找和排序（search &amp; sort）"></a>查找和排序（search &amp; sort）</h2><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><strong>Input：</strong></p>
<p>[6501,6828,6963,7036,7422,7674,8146,8468,8704,8717,9170,9359,9719,9895,9896,9913,9962,154,293,334,492,1323,1479,1539,1727,1870,1943,2383,2392,2996,3282,3812,3903,4465,4605,4665,4772,4828,5142,5437,5448,5668,5706,5725,6300,6335]</p>
<p><strong>Output：</strong></p>
<p>154</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 3s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本体的关键条件是已排序数组，因此旋转之后的数组仍存在具有有序性。利用这个规律二分查找转折点就是最小值所在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        if (rotateArray.size() == 0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int first = 0;</div><div class="line">        int last = rotateArray.size()-1;</div><div class="line">        int mid = -1;</div><div class="line">        while (true)&#123;</div><div class="line">            if (last - first == 1)&#123;</div><div class="line">                mid = last;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            mid = first + (last - first) / 2;</div><div class="line">            if (rotateArray[mid] &lt;= rotateArray[last])&#123;</div><div class="line">                last = mid;</div><div class="line">            &#125;</div><div class="line">            if (rotateArray[mid] &gt;= rotateArray[first])&#123;</div><div class="line">                first = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[first];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="数组中出现次数超过一半的数"><a href="#数组中出现次数超过一半的数" class="headerlink" title="数组中出现次数超过一半的数"></a>数组中出现次数超过一半的数</h3><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字，如果不存在则输出0。<br><strong>Input：</strong></p>
<p>{1,2,3,2,2,2,5,4,2}</p>
<p><strong>Output：</strong></p>
<p>2</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题属于经典题目之一，其解法和思路多种多样，包括最基本的排序取中间值；每次删除2个不同的元素，以及利用两个变数candidate和nTime来动态规划。遍历数组，利用candidate参数记录一个元素，并用nTime参数记录当前该元素出现次数，如果下一个相同则nTime加1，否则减1。直到nTime等于0，candidate替换成下一个出现的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def MoreThanHalfNum_Solution(self, numbers):</div><div class="line">        # write code here</div><div class="line">        if not numbers:</div><div class="line">            return 0</div><div class="line">        if len(numbers) == 1:</div><div class="line">            return numbers[0]</div><div class="line">        numbers = sorted(numbers)</div><div class="line">        n = len(numbers)</div><div class="line">        if n % 2 == 0:</div><div class="line">            if numbers[int(n / 2)] == numbers[int(n / 2) - 1]:</div><div class="line">                return numbers[int(n / 2)]</div><div class="line">        else:</div><div class="line">            if numbers[int(n / 2)] == numbers[int(n / 2) + 1]:</div><div class="line">                return numbers[int(n / 2)]</div><div class="line">        return 0</div></pre></td></tr></table></figure>
<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>题目：输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br><strong>Input：</strong></p>
<p>{10,5,12,4,7}, 22</p>
<p><strong>Output：</strong></p>
<p>[[10,5,7],[10,12]]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 求和为定值的问题最先想到的应该是利用递归的方式考虑所有可能路径数字组合的DFS问题。只是这次的数据结构换成了二叉树，因此搜索的方向变成了树的深度方向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    # 返回二维列表，内部每个列表表示找到的路径</div><div class="line">    def FindPath(self, root, expectNumber):</div><div class="line">        # write code here</div><div class="line">        if not root:</div><div class="line">            return []</div><div class="line">        if root and not root.left and not root.right and root.val == expectNumber:</div><div class="line">            return [[root.val]]</div><div class="line">        res = []</div><div class="line">        left = self.FindPath(root.left, expectNumber - root.val)</div><div class="line">        right = self.FindPath(root.right, expectNumber - root.val)</div><div class="line">        for i in left+right:</div><div class="line">            res.append([root.val] + i)</div><div class="line">        return res</div></pre></td></tr></table></figure>
<h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><p>题目：统计一个数字在排序数组中出现的次数。<br><strong>Input：</strong></p>
<p>[1,2,3,3,3,3,4,5], 3</p>
<p><strong>Output：</strong></p>
<p>4</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 一个典型的利用二分查找的思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def GetNumberOfK(self, data, k):</div><div class="line">        # write code here</div><div class="line">        if len(data) == 0:</div><div class="line">        	return 0</div><div class="line">        left = 0</div><div class="line">        right = len(data)-1</div><div class="line">        while left &lt;= right:</div><div class="line">            mid = int(left + (right - left) / 2)</div><div class="line">            if data[mid] == k:</div><div class="line">                first, last = mid, mid</div><div class="line">                if data[first] == data[0]:</div><div class="line">                    first = 0</div><div class="line">                else:</div><div class="line">                    while data[first - 1] == k:</div><div class="line">                        first -= 1</div><div class="line">                if data[last] == data[-1]:</div><div class="line">                    last = len(data) - 1</div><div class="line">                else:</div><div class="line">                    while data[last + 1] == k:</div><div class="line">                        last += 1</div><div class="line">                return last - first + 1</div><div class="line">            elif data[mid] &gt; k:</div><div class="line">                right = mid - 1</div><div class="line">            else:</div><div class="line">                left = mid + 1</div><div class="line">        return 0</div></pre></td></tr></table></figure>
<h3 id="和为定值的连续正数序列"><a href="#和为定值的连续正数序列" class="headerlink" title="和为定值的连续正数序列"></a>和为定值的连续正数序列</h3><p>题目：小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<br><strong>Input：</strong></p>
<p>3</p>
<p><strong>Output：</strong></p>
<p>[[1,2]]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题可以使用双指针的思路解决。一大一小两个指针分别位移，终止条件为小指针大于总数的一半（两个数都大于一半和一定超过总数）。因为是连续的，因此如果大小指针和小于总数，只要把大指针加1继续扩大和就行，同时当前总数加上新的值。如果等于总数，则输出小指针到大指针之间的所有数。如果当前总数大于总数，则小指针加1，同时当前总数减去新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def FindContinuousSequence(self, tsum):</div><div class="line">        # write code here</div><div class="line">        if tsum &lt; 3:</div><div class="line">            return []</div><div class="line">        small = 1</div><div class="line">        big = 2</div><div class="line">        ans = []</div><div class="line">        cur = small + big</div><div class="line">        stop = int((1 + tsum) / 2)</div><div class="line">        while small &lt; stop:</div><div class="line">            if tsum == cur:</div><div class="line">                ans.append(list(range(small, big+1)))</div><div class="line">                big += 1</div><div class="line">                cur += big</div><div class="line">            elif tsum &gt; cur:</div><div class="line">                big += 1</div><div class="line">                cur += big</div><div class="line">            else:</div><div class="line">                cur -= small</div><div class="line">                small += 1</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="和为定制的两个数"><a href="#和为定制的两个数" class="headerlink" title="和为定制的两个数"></a>和为定制的两个数</h3><p>题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br><strong>Input：</strong></p>
<p>[1,2,4,7,11,15], 15</p>
<p><strong>Output：</strong></p>
<p>[4,11]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 因为数组为递增排序的数组，因此考虑使用大小指针进行解答。另外需要判断输出的多样性，需要对所有结果进行乘积的比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def FindNumbersWithSum(self, array, tsum):</div><div class="line">        # write code here</div><div class="line">        if len(array) == 0:</div><div class="line">            return []</div><div class="line">        if len(array) == 1:</div><div class="line">            return array[0]</div><div class="line">        left = 0</div><div class="line">        right = len(array) - 1</div><div class="line">        ans = []</div><div class="line">        flag = True</div><div class="line">        while left &lt; right:</div><div class="line">            cur = array[left] + array[right]</div><div class="line">            if tsum == cur:</div><div class="line">                if flag:</div><div class="line">                    temp = array[left] * array[right]</div><div class="line">                    flag = False</div><div class="line">                    ans = [array[left], array[right]]</div><div class="line">                else:</div><div class="line">                    if array[left] * array[right] &lt; temp:</div><div class="line">                        temp = array[left] * array[right]</div><div class="line">                        ans = [array[left], array[right]]</div><div class="line">                left += 1</div><div class="line">                right -= 1</div><div class="line">            elif tsum &gt; cur:</div><div class="line">                left += 1</div><div class="line">            else:</div><div class="line">                right -= 1</div><div class="line">        return ans</div></pre></td></tr></table></figure>
<h3 id="二叉树的分层列印"><a href="#二叉树的分层列印" class="headerlink" title="二叉树的分层列印"></a>二叉树的分层列印</h3><p>题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><strong>Input：</strong></p>
<p>{8,6,10,5,7,9,11}</p>
<p><strong>Output：</strong></p>
<p>[[8],[6,10],[5,7,9,11]]</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 二叉树的分层打印是经典算法之一，其主要思想是在传统的BFS算法基础上维护两个变量来判断换行的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    # 返回二维列表[[1,2],[4,5]]</div><div class="line">    def Print(self, pRoot):</div><div class="line">        # write code here</div><div class="line">        if not pRoot:</div><div class="line">            return []</div><div class="line">        queue = [pRoot]</div><div class="line">        last = pRoot</div><div class="line">        nlast = pRoot</div><div class="line">        res, cand = [], []</div><div class="line">        while len(queue) != 0:</div><div class="line">            temp = queue.pop(0)</div><div class="line">            cand.append(temp.val)</div><div class="line">            if temp.left:</div><div class="line">                queue.append(temp.left)</div><div class="line">                nlast = temp.left</div><div class="line">            if temp.right:</div><div class="line">                queue.append(temp.right)</div><div class="line">                nlast = temp.right</div><div class="line">            if last == temp:</div><div class="line">                last = nlast</div><div class="line">                res.append(cand)</div><div class="line">                cand = []</div><div class="line">        return res</div></pre></td></tr></table></figure>
<h3 id="二叉检索树的第k大节点"><a href="#二叉检索树的第k大节点" class="headerlink" title="二叉检索树的第k大节点"></a>二叉检索树的第k大节点</h3><p>题目：给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。<br><strong>Input：</strong></p>
<p>{5,3,7,2,4,6,8}</p>
<p><strong>Output：</strong></p>
<p>4</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 本题利用了二叉检索树的性质，就是左子树的节点小于根节点小于右子树的节点。根据这个规律利用中序遍历的方式可以得到排序后的节点数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    # 返回对应节点TreeNode</div><div class="line">    def middle_traversal(self, root, ans):</div><div class="line">        if not root:</div><div class="line">            return</div><div class="line">        self.middle_traversal(root.left, ans)</div><div class="line">        ans.append(root)</div><div class="line">        self.middle_traversal(root.right, ans)</div><div class="line">    def KthNode(self, pRoot, k):</div><div class="line">        # write code here</div><div class="line">        ans = []</div><div class="line">        self.middle_traversal(pRoot, ans)</div><div class="line">        if k &lt;= 0 or len(ans) &lt; k:</div><div class="line">            return None</div><div class="line">        return ans[k-1]</div></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p>题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><strong>Input：</strong></p>
<p>6</p>
<p><strong>Output：</strong></p>
<p>2</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 看到二进制问题首先想到的应该是位运算，将数字n右移一位的结果和1作and位运算，就可以知道当前位是否为1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def NumberOf1(self, n):</div><div class="line">        # write code here</div><div class="line">        return sum([(n &gt;&gt; a &amp; 1) for a in range(32)])</div></pre></td></tr></table></figure>
<h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、<em>、/四则运算符号。<br><em>*Input：</em></em></p>
<p>4, 5</p>
<p><strong>Output：</strong></p>
<p>9</p>
<p><strong>Requirement：</strong></p>
<p>Time limit = 1s, Space limit = 32768K</p>
<p><strong>思路：</strong> 经典的位运算运用，两个数的加法等于两数的xor加上2*两书的and。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def Add(self, num1, num2):</div><div class="line">        # write code here</div><div class="line">        return (num1 ^ num2) + ((num1 &amp; num2) &lt;&lt; 1)</div></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-11-02T05:58:59.042Z" itemprop="dateUpdated">2017-11-02 13:58:59</time>
</span><br>


        
        如果我的文章对你有帮助，请打个赏。谢谢～～
        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/one2.jpg" alt="Eternal">
            Eternal
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/11/02/Algorithm/&title=《剑指offer算法编程题（Python、C++、Java）》 — 指尖の岁月&pic=http://yoursite.com/img/one2.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/11/02/Algorithm/&title=《剑指offer算法编程题（Python、C++、Java）》 — 指尖の岁月&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/11/02/Algorithm/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《剑指offer算法编程题（Python、C++、Java）》 — 指尖の岁月&url=http://yoursite.com/2017/11/02/Algorithm/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/11/02/Algorithm/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/10/17/GAN/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">对抗生成网络(GAN)</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'eternalfeather';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您~~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Eternal &copy; 2015 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/11/02/Algorithm/&title=《剑指offer算法编程题（Python、C++、Java）》 — 指尖の岁月&pic=http://yoursite.com/img/one2.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/11/02/Algorithm/&title=《剑指offer算法编程题（Python、C++、Java）》 — 指尖の岁月&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/11/02/Algorithm/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《剑指offer算法编程题（Python、C++、Java）》 — 指尖の岁月&url=http://yoursite.com/2017/11/02/Algorithm/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/11/02/Algorithm/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABv0lEQVR42u3aQW7DMAwEwPz/0ynQU4E0DpeUVBcYnYzEUMY5EOTKj0d5Pb/Xz+vX9fpt/ZPFCxcXd8x9Xq5r7vyTugEXF/c8t1683j1qpQhW6B9suLi4N+PuaJVwcXH/Ozcde3p0XFzc+3AnYUfa+lR2WzCr4eLiDrirWpPJ9fZ8FxcXd9GpRFpQ0p+Pfx0XF/cI9zrQTCPUXmwa74aLi3ucW6dPXq2o7/khxcHFxd3GvW44eqWn/ppF8y/DxcU9yO21NekrXAsKIi4u7hFuPdqob1rBVUpY/B/j4uKOufsOU+fh6WNSWXFxcVvctCT1jlXmQQkuLu5JblpcdtyTDlS4uLhnuPXRJQ0v0ofBxcW9AzcNJtKXqHpx6tujFFxc3CPc4KalZxnpUISLi3uSWx9LKg9Tz2ivA9m3j4SLi3uQW08jewPS5NAFFxf3r7jpSDNpeurHt8FJLC4u7lJuWlB60Ua90al/i4uLu5tbjz7rpTANTIO4BBcX9yC33o6k7UsasC6Yw3BxcQ9y05hjXv5+2QEXF/eW3F5bkzY3uLi4d+CmiMmhaRqFNGMRXFzcAXcSmK4ahHqRKy4u7gbuF2mYqUBCkXQ2AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'Welcome back!';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂) Hello!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
